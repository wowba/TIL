# HTTP

처음 웹 개발을 공부할때 http를 제대로 이해하지 않으면

대부분의 기능의 원리를 제대로 이해할 수 없다. 단순히 사용하기만 할줄 알 뿐!

웹 개발자는 평생 http 기반 위에서 개발해야 하기에 한번은 꼭 정리해야한다.

실무에 꼭 필요한 http 기본 지식을 습득하자!

# 인터넷 네트워크

인터넷 네트워크는 http 학습을 위해 기본적으로 알아야 한다.

### 인터넷 통신

클라이언트가 서버에게 정보를 전달하려면,

`인터넷 프로토콜`에 대해 이해해야 한다.

인터넷 프로토콜, 즉 `IP`라는 주소를 클라이언트가 부여받는다.

IP는 지정한 IP 주소에 데이터를 전달하고, 패킷이라는 통신 단위로 데이터를 전달한다.
`IP 패킷` 이라는 규칙은 출발지,목적지의 IP 등을 적고 인터넷망에 던지면
이 프로토콜에 의해 목적지가 존재하는 서버에 전달되게 된다.

### IP 프로토콜의 한계

비연결성 - 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

비신뢰성 - 중간에 패킷이 사라지면?(패킷소실) / 패킷이 순서대로 안오면?

프로그램 구분 - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

이 문제들을 해결해 주는게 `TCP 프로토콜` 이다

### TCP / UDP

인터넷 프로토콜 스택의 4계층은 다음과 같다

- 애플리케이션 계층 - HTTP, FTP
- 전송계층 - TCP / UDP
- 인터넷 계층 - IP
- 네트워크 인터페이스 계층

위에서 아래로 순서대로 데이터가 전달되면서 해당 계층의 정보가 데이터를 감싸며,
네트워크 인터페이스에서 랜카드를 통해 인터넷에 접속한다.

`IP 패킷` 안쪽에 있는 `TCP 세그먼트`는 다양한 정보를 담고있다.
출발지, 목적지 PORT / 전송 제어 / 순서 / 검증 정보 등, IP패킷 만으로
해결이 안됐던 문제들을 해결해준다.

TCP(전송 제어 프로토콜)의 특징은 다음과 같다.

- 연결지향 -> TCP 3 way handshake (가상 연결)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 대부분 애플리케이션에서 TCP 사용

`TCP 3 way handskake`의 순서는 다음과 같다. / SYC = 접속요청, ACK = 요청수락

1. 클라이언트가 서버에 접속 요청 (SYC)
2. 요청을 수락, 및 클라이언트에 보낸다 (SYC + ACK)
3. 클라이언트가 다시 서버에 ACK를 보낸다.
   그 후 서로 데이터 전송.

`데이터 전달 보증` 은 클라이언트가 서버에 데이터를 보내면
다시 서버에서 클라이언트에게 잘 받았다고 연락을 준다.

`순서 보장` 은 데이터가 서버에 도착 시 패킷 순서가 잘못되어있으면 그 잘못된 순서부터
다시 보내달라고도 요청할 수 있다. 물론 최적화에 따라 다르다.

`UDP 프로토콜`의 특징은 다음과 같다. (사용자 데이터그램 프로토콜)
이건 IP처럼 기능이 거의 없지만 `PORT`가 추가가 된다.

TCP 는 최적화 하기 힘들지만, UDP를 사용하면 최적화를 할 수 있다.
최근에는 UDP가 뜨고있는데, 엄청난 최적화를 통해 발전하고 있다.

### PORT

클라이언트가 한번에 여러 서버와 통신을 하게 되면 패킷이 날라올 때 혼란이 올 수 있다.

그래서 패킷에는 출발지, 목적지 PORT가 있어 프로세스가 구분이 가능하다!

즉, IP 가 아파트면, PORT는 그 안에 몇동 몇호 라고 생각하면 편하다.

0 ~ 65535 포트가 할당 가능하지만

0 ~ 1023 포트는 피하는게 좋다. 이미 많이 사용하고 있음.
FTP - 20, 21
TELNET - 23
HTTP - 80
HTTPS - 443

### DNS

IP의 문제는, 첫째로 기억하기 어렵다는것. 두번째로 변경될 수 있다는 점이 있다.

그래서 `Domain Name System`, 즉 DNS가 생겼다.

하나의 전화번호부와 같은 DNS는 도메인 명을 IP 주소로 변환시켜 준다.

# URI 와 웹 브라우저 요청 흐름

### URI (Unifrom Resource Identifier)

URI 라는 가장 큰 개념은 서로 겹치지 않는

URL (Resource Locator) 과 URN (Resource Name) 을 포함하고 있다. URN은 거의 사용하지 않는다.

URI 설명

- Uniform = 리소스를 식별하는 통일된 방식
- Resource = 자원, URI 로 식별할 수 있는 모든 것(제한 없음)
- Identifier = 다른 항목과 구분하는데 필요한 정보

URL, URN 설명

- URL (Locator) = 리소스가 있는 위치를 지정
- URN (Name) = 리소스에 이름을 부여
- 위치는 변할 수 있지만 이름은 변하지 않는다. 하지만 이름만으로 실제 리소스를 찾을 수 있는 방법은
  보편화 되지 않았다.

### URL 분석

구조
scheme://\[userinfo@]\[host]\[:port]\[/path]\[?query]\[#fragment]
예시
https://www.google.com/search?q=hello&hi=ko

- scheme = 주로 프로토콜 사용 / 프로토콜 = 어떤 방식으로 자원에 접글할 것인가 하는 규칙
  (http, https, ftp 등등)

http는 80, https는 443 포트를 주로 사용. 포트는 생략 가능.

https는 http에 보안 추가 (HTTP Secure)

- userinfo = URL에 사용자 정보를 포함해서 인증, 하지만 거의 안씀.

- host = 호스트 명 / 도메인 명 혹은 IP주소 직접 사용 가능

- port = 접속 포트 / 일반적으로 생략.

- path = 리소스 경로(계층적 구조) ex) /home/file1.jpg, /members, /members/100 등

- query = key=value 형태. ?로 시작, &로 계속 추가 가능. query parameter, query string 등으로 불린다.

- fragment = html 내부 북마크 등에 사용, 서버에 전송하는 정보는 아님.

### 웹 브라우저 요청 흐름

https://www.google.com/search?q=hello&hi=ko 이 주소로 요청을 보내면

1. IP와 PORT 정보를 찾아낸다. / www.google.com:443
2. HTTP 요청 메세지를 보낸다
3. SOCKET 라이브러리를 통해 전달한다 / TCP/IP 연결(IP,PORT), 데이터 전달
4. TCP/IP 패킷 생성, HTTP 메시지 포함.
5. 클라이언트가 서버에게 요청 패킷 전달 / 서버에 요청 패킷 도착.
6. 서버에서 다시 요청 패킷 출발 / 클라이언트에게 패킷 도착
7. 클라이언트의 브라우저에서 HTML 렌더링.

# HTTP

### 모든것이 HTTP

HTTP 는 HyperText Transfer Protocol. 문서간 링크를 통해 연결할 수 있는 것이다.

하지만 이제는 HTTP 메시지에 거의 모든 형태의 데이터를 전송 가능하다.

HTTP/1.1, 2 는 TCP 를 기반으로 하지만, HTTP/3 는 UDP 를 기반으로 한다.

현재는 1.1을 주로 사용하지만, 2, 3 도 점점 증가하고 있다. 이 둘은 1.1의 성능 개선 버전이기에 1.1을 잘 배우면 된다.

HTTP의 특징

- 클라이언트 서버 구조
- 무상태 프로토콜(스테이트리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

### 클라이언트 서버 구조

- Request, Response 구조
- 클라이언트는 서버에 요층을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답

### 무상태 프로토콜 (Stateless)

- 서버가 클라이언트의 상태를 보존하지 않음 / 필요시 바로 응답 및 서버 장애시 다른 서버로 전달.
- 스케일 아웃, 수평 확장에 매우 유리함.

Stateless의 한계

- 상태를 유지해야 하는 경우(로그인)
- 일반적으로 브라우저 쿠키와 서버 세션등을 이용해 유지함
- 상태 유지는 최소한만 사용한다.
- 클라이언트가 Stateful에 비해 상대적으로 받는 데이터의 양이 증가함.

### 비 연결성 (Connectionless)

- 연결을 유지하는 모델

여러 클라이언트가 하나의 서버에 연결을 한다면, 서버는 모든 연결을 유지할것이고 자원을 소모한다.

이렇게 되면 다른 클라이언트가 놀고 있어도 서버는 연결을 유지해야 하는 단점이 있다.

- 연결을 유지하지 않는 모델

요청과 응답이 바로 끝나고 나면 연결을 바로 끊어버린다.

이렇게 하면 서버는 연결을 유지할 필요가 없고, 최소한의 자원만 사용할 수 있다.

HTTP 는 기본적으로 연결을 유지하지 않는 모델.

일반적으로 초 단위 이하의 빠른 속도로 응답하며, 1시간동안 수천명이 서비스를 사용해도

실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다

--> 서버 자원을 매유 효율적으로 사용할 수 있다.

- 비 연결성의 한계

TCP/IP 연결을 새로 맺을때마다 3 way handshake 시간 추가

웹 브라우저로 사이트를 요청하면 HTML 뿐 아니라 JS, CSS 등을 전부 다운받아야 한다.

하지만 지금은 HTTP 지속 연결(Persistent Connection)로 문제를 해결하며, HTTP/2, 3 에서 더 많은 최적화가 이루어졌다.
