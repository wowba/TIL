# HTTP

처음 웹 개발을 공부할때 http를 제대로 이해하지 않으면

대부분의 기능의 원리를 제대로 이해할 수 없다. 단순히 사용하기만 할줄 알 뿐!

웹 개발자는 평생 http 기반 위에서 개발해야 하기에 한번은 꼭 정리해야한다.

실무에 꼭 필요한 http 기본 지식을 습득하자!

# 인터넷 네트워크

인터넷 네트워크는 http 학습을 위해 기본적으로 알아야 한다.

### 인터넷 통신

클라이언트가 서버에게 정보를 전달하려면,

`인터넷 프로토콜`에 대해 이해해야 한다.

인터넷 프로토콜, 즉 `IP`라는 주소를 클라이언트가 부여받는다.

IP는 지정한 IP 주소에 데이터를 전달하고, 패킷이라는 통신 단위로 데이터를 전달한다.
`IP 패킷` 이라는 규칙은 출발지,목적지의 IP 등을 적고 인터넷망에 던지면
이 프로토콜에 의해 목적지가 존재하는 서버에 전달되게 된다.

### IP 프로토콜의 한계

비연결성 - 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송

비신뢰성 - 중간에 패킷이 사라지면?(패킷소실) / 패킷이 순서대로 안오면?

프로그램 구분 - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

이 문제들을 해결해 주는게 `TCP 프로토콜` 이다

### TCP / UDP

인터넷 프로토콜 스택의 4계층은 다음과 같다

- 애플리케이션 계층 - HTTP, FTP
- 전송계층 - TCP / UDP
- 인터넷 계층 - IP
- 네트워크 인터페이스 계층

위에서 아래로 순서대로 데이터가 전달되면서 해당 계층의 정보가 데이터를 감싸며,
네트워크 인터페이스에서 랜카드를 통해 인터넷에 접속한다.

`IP 패킷` 안쪽에 있는 `TCP 세그먼트`는 다양한 정보를 담고있다.
출발지, 목적지 PORT / 전송 제어 / 순서 / 검증 정보 등, IP패킷 만으로
해결이 안됐던 문제들을 해결해준다.

TCP(전송 제어 프로토콜)의 특징은 다음과 같다.

- 연결지향 -> TCP 3 way handshake (가상 연결)
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 대부분 애플리케이션에서 TCP 사용

`TCP 3 way handskake`의 순서는 다음과 같다. / SYC = 접속요청, ACK = 요청수락

1. 클라이언트가 서버에 접속 요청 (SYC)
2. 요청을 수락, 및 클라이언트에 보낸다 (SYC + ACK)
3. 클라이언트가 다시 서버에 ACK를 보낸다.
   그 후 서로 데이터 전송.

`데이터 전달 보증` 은 클라이언트가 서버에 데이터를 보내면
다시 서버에서 클라이언트에게 잘 받았다고 연락을 준다.

`순서 보장` 은 데이터가 서버에 도착 시 패킷 순서가 잘못되어있으면 그 잘못된 순서부터
다시 보내달라고도 요청할 수 있다. 물론 최적화에 따라 다르다.

`UDP 프로토콜`의 특징은 다음과 같다. (사용자 데이터그램 프로토콜)
이건 IP처럼 기능이 거의 없지만 `PORT`가 추가가 된다.

TCP 는 최적화 하기 힘들지만, UDP를 사용하면 최적화를 할 수 있다.
최근에는 UDP가 뜨고있는데, 엄청난 최적화를 통해 발전하고 있다.

### PORT

클라이언트가 한번에 여러 서버와 통신을 하게 되면 패킷이 날라올 때 혼란이 올 수 있다.

그래서 패킷에는 출발지, 목적지 PORT가 있어 프로세스가 구분이 가능하다!

즉, IP 가 아파트면, PORT는 그 안에 몇동 몇호 라고 생각하면 편하다.

0 ~ 65535 포트가 할당 가능하지만

0 ~ 1023 포트는 피하는게 좋다. 이미 많이 사용하고 있음.
FTP - 20, 21
TELNET - 23
HTTP - 80
HTTPS - 443

### DNS

IP의 문제는, 첫째로 기억하기 어렵다는것. 두번째로 변경될 수 있다는 점이 있다.

그래서 `Domain Name System`, 즉 DNS가 생겼다.

하나의 전화번호부와 같은 DNS는 도메인 명을 IP 주소로 변환시켜 준다.

# URI 와 웹 브라우저 요청 흐름

### URI (Unifrom Resource Identifier)

URI 라는 가장 큰 개념은 서로 겹치지 않는

URL (Resource Locator) 과 URN (Resource Name) 을 포함하고 있다. URN은 거의 사용하지 않는다.

URI 설명

- Uniform = 리소스를 식별하는 통일된 방식
- Resource = 자원, URI 로 식별할 수 있는 모든 것(제한 없음)
- Identifier = 다른 항목과 구분하는데 필요한 정보

URL, URN 설명

- URL (Locator) = 리소스가 있는 위치를 지정
- URN (Name) = 리소스에 이름을 부여
- 위치는 변할 수 있지만 이름은 변하지 않는다. 하지만 이름만으로 실제 리소스를 찾을 수 있는 방법은
  보편화 되지 않았다.

### URL 분석

구조
scheme://\[userinfo@]\[host]\[:port]\[/path]\[?query]\[#fragment]
예시
https://www.google.com/search?q=hello&hi=ko

- scheme = 주로 프로토콜 사용 / 프로토콜 = 어떤 방식으로 자원에 접글할 것인가 하는 규칙
  (http, https, ftp 등등)

http는 80, https는 443 포트를 주로 사용. 포트는 생략 가능.

https는 http에 보안 추가 (HTTP Secure)

- userinfo = URL에 사용자 정보를 포함해서 인증, 하지만 거의 안씀.

- host = 호스트 명 / 도메인 명 혹은 IP주소 직접 사용 가능

- port = 접속 포트 / 일반적으로 생략.

- path = 리소스 경로(계층적 구조) ex) /home/file1.jpg, /members, /members/100 등

- query = key=value 형태. ?로 시작, &로 계속 추가 가능. query parameter, query string 등으로 불린다.

- fragment = html 내부 북마크 등에 사용, 서버에 전송하는 정보는 아님.

### 웹 브라우저 요청 흐름

https://www.google.com/search?q=hello&hi=ko 이 주소로 요청을 보내면

1. IP와 PORT 정보를 찾아낸다. / www.google.com:443
2. HTTP 요청 메세지를 보낸다
3. SOCKET 라이브러리를 통해 전달한다 / TCP/IP 연결(IP,PORT), 데이터 전달
4. TCP/IP 패킷 생성, HTTP 메시지 포함.
5. 클라이언트가 서버에게 요청 패킷 전달 / 서버에 요청 패킷 도착.
6. 서버에서 다시 요청 패킷 출발 / 클라이언트에게 패킷 도착
7. 클라이언트의 브라우저에서 HTML 렌더링.

# HTTP

### 모든것이 HTTP

HTTP 는 HyperText Transfer Protocol. 문서간 링크를 통해 연결할 수 있는 것이다.

하지만 이제는 HTTP 메시지에 거의 모든 형태의 데이터를 전송 가능하다.

HTTP/1.1, 2 는 TCP 를 기반으로 하지만, HTTP/3 는 UDP 를 기반으로 한다.

현재는 1.1을 주로 사용하지만, 2, 3 도 점점 증가하고 있다. 이 둘은 1.1의 성능 개선 버전이기에 1.1을 잘 배우면 된다.

HTTP의 특징

- 클라이언트 서버 구조
- 무상태 프로토콜(스테이트리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

### 클라이언트 서버 구조

- Request, Response 구조
- 클라이언트는 서버에 요층을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어서 응답

### 무상태 프로토콜 (Stateless)

- 서버가 클라이언트의 상태를 보존하지 않음 / 필요시 바로 응답 및 서버 장애시 다른 서버로 전달.
- 스케일 아웃, 수평 확장에 매우 유리함.

Stateless의 한계

- 상태를 유지해야 하는 경우(로그인)
- 일반적으로 브라우저 쿠키와 서버 세션등을 이용해 유지함
- 상태 유지는 최소한만 사용한다.
- 클라이언트가 Stateful에 비해 상대적으로 받는 데이터의 양이 증가함.

### 비 연결성 (Connectionless)

- 연결을 유지하는 모델

여러 클라이언트가 하나의 서버에 연결을 한다면, 서버는 모든 연결을 유지할것이고 자원을 소모한다.

이렇게 되면 다른 클라이언트가 놀고 있어도 서버는 연결을 유지해야 하는 단점이 있다.

- 연결을 유지하지 않는 모델

요청과 응답이 바로 끝나고 나면 연결을 바로 끊어버린다.

이렇게 하면 서버는 연결을 유지할 필요가 없고, 최소한의 자원만 사용할 수 있다.

HTTP 는 기본적으로 연결을 유지하지 않는 모델.

일반적으로 초 단위 이하의 빠른 속도로 응답하며, 1시간동안 수천명이 서비스를 사용해도

실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작다

--> 서버 자원을 매유 효율적으로 사용할 수 있다.

- 비 연결성의 한계

TCP/IP 연결을 새로 맺을때마다 3 way handshake 시간 추가

웹 브라우저로 사이트를 요청하면 HTML 뿐 아니라 JS, CSS 등을 전부 다운받아야 한다.

하지만 지금은 HTTP 지속 연결(Persistent Connection)로 문제를 해결하며, HTTP/2, 3 에서 더 많은 최적화가 이루어졌다.

### HTTP 메세지

HTTP 메세지는 요청, 응답 2가지가 있는데 구조는 각각이 조금씩 다르다.

시작라인 / 헤더 / 공백라인 / message body 이렇게 있으며 공식 스펙은 다음과 같다.

```
HTTP-message   = start-line
                 *( header-field CRLF )
                 CRLF  <-- 공백 한줄
                 [ message-body ]
```

- start-line
  start-line은 `request-line` / `status-line` 두가지가 있다.
  `request-line`(요청 메세지)는 method SP(공백) request-target SP(공백) HTTP-version CRLF(엔터) 와 같다.
  `status-line`(응답 메세지)는 HTTP-version SP(공백) status-code SP(공백) reason-phrase CRLF(엔터) 와 같다.

- HTTP 헤더
  `header-field` = field-name ":" OWS field-value OWS ( OWS : 띄어쓰기 허용 )
  field-name은 대소문자 구분이 없다.

  HTTP 헤더는 HTTP 전송에 필요한 모든 부가정보가 들어있다. (메시지 바디 내용, 메시지 바디 크기, 압축, 인증, 요청 클라이언트 등등...)
  또한 필요시 임의의 헤더 추가가 가능하다.

- HTTP 메시지 바디
  실제 전송할 데이터가 들어있다.
  HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 전송 가능

- HTTP의 단순함과 확장 가능성
  HTTP 메시지도 매우 단순하고 스펙도 읽어볼 만 하며,
  크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술임을 알 수 있다.

# HTTP Method

### HTTP Method 종류

`주요 Method`

- GET: 리스소 조회
  서버에 전달하고 싶은 데이터는 query를 통해서 전달한다.
  메세지 바디를 사용해서 데이터를 전송할 수 있지만, 지원하지 않는 곳이 많다.

- POST: 요청 데이터 처리, 주로 등록에 사용
  메시지 바디를 통해 서버로 요청 데이터를 전달하고, 서버는 요청 데이터를 처리한다.
  즉, 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
  주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용한다.
  또한 다른 method로 처리하기 애매한 경우에도 사용한다.
- PUT: 기존 리소스를 `완전히 대체`, 해당 리소스가 없으면 `생성`
  put은 쉽게 얘기해서 기존 파일을 덮어버리거나 새로 생성하는 method이다.
  또한 클라이언트가 리소스 위치를 알고 URI를 지정하는데, 이 부분에서 POST와는 다르다.
  기존 리소스를 완전히 지워버리고 대체하기 때문에 사용에 주의하자.

- PATCH: 리소스 부분 변경
  기존 리소스의 일부 부분만 변경이 가능해 리소스 업데이트 등에 사용할 수 있다
  서버가 PATCH를 이해하지 못하는 경우 POST를 쓰면 된다.

- DELETE: 리소스 삭제
  기존에 있던 리소스를 삭제한다.
  `기타 Method`

- HEAD: GET과 동일하지만 메시지 부분을 제외하고 상태 줄, 헤더만 변환
- OPTIONS: 대상 리소스에 대한 통신 가능옵션을 설명 (주로 CORS에서 사용)
- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정 / `거의 사용하지 않음`
- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행 / `거의 사용하지 않음`

### HTTP Method의 속성

- 안전(Safe)
  호출해도 대상 리소스를 변경하지 않는다.

- 멱등(Iempotent)
  몇번을 호출하던 결과가 똑같이 나와야 한다.
  멱등 method 로는
  GET - 몇번을 호출하던 같은 결과 조회,
  PUT - 결과를 대체. 같은 요청을 여러번 해도 최종 결과는 같음,
  DELETE - 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.

  멱등의 경우에는 자동 복구 메커니즘,
  서버가 Timeout 등으로 정상 응답을 못주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 의 판단 근거.
  `멱등은 외부 요인으로 중간에 리소스가 변경되는것 까지는 고려하지 않는다.`

- 캐시 가능(Cacheable)
  응답 결과 리소스를 캐시로 저장해 사용할 수 있는가?
  GET, HEAD, POST, PATCH 캐시 가능하지만, 실제로는 GET, HEAD 정도만 캐시로 사용한다.

### HTTP API 리소스

좋은 URI 설계는 `리소스 식별`을 최우선으로 두고 설계하는 것이다.
회원 관리 시스템의 경우, 회원이라는 개념 자체가 `리소스`이다.
즉, 회원을 등록하고 수정하고 조회하는것을 URI에 모두 배제하여 `회원`이라는 `리소스`만 식별하게 한다.
--> `회원 리소스를 URI 에 매핑`, 그 뒤는 method로 기능을 분류한다!!

회원 관리 API URI 설계 ( Uniform Resource Identifier ) / 리소스 = 회원 / 행위 = 조회, 등록, 삭제, 변경 (method)

# HTTP method 활용

### 클라이언트에서 서버로 데이터 전송

데이터 전달 방식은 크게 2가지가 있다.

1. 쿼리 파라미터를 통한 데이터 전송

- GET
- 주로 정렬 필터(검색어)

2. 메시지 바디를 통한 데이터 전송

- POST, PUT, PATCH
- 회원가입, 상품주문, 리소스 등록, 리소스 변경 등.

보통 데이터 전송에선 크게 4가지 상황이 있다.

1. 정적 데이터 조회 - 쿼리 파라미터 미사용 / GET
   보통 일반적으로 정적 데이터는 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능

2. 동적 데이터 조회 - 쿼리 파라미터 사용 / GET
   주로 검색, 게시판 목록에서 정렬 필터
   필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용한다.
   GET은 쿼리 파라미터를 사용해서 데이터를 전달한다.

3. HTML Form 데이터 전송 / POST
   주로 회원가입, 상품 주문, 데이터 변경 등 정보 보내기, 수정, 추가 등에 사용.

/ multipart/form-data
정보 뿐만 아니라 다양한 파일(바이너리 데이터)들을 넣어서 보낼 수 있음.
다른 종류의 여러 파일들과 폼의 내용 함께 전송 가능!!

4. HTTP API 데이터 전송
   주로 회원가입, 상품 주문, 데이터 변경 등 정보 보내기, 수정, 추가 등
   서버 TO 서버 전송 (백엔드 시스템 통신)
   앱 클라이언트 - 아이폰/안드로이드
   웹 클라이언트 - Form 대신 자바 스크립트를 통한 통신 (React, VueJs 같은 웹 클라이언트와 API 통신)

### HTTP API 설계 예시

1. HTTP API 컬렉션 / POST 기반 등록 (ex: 회원 관리 API 제공)

- 회원 목록 /members -> GET
- 회원 등록 /members -> POST
- 회원 조회 /members/{id} -> GET
- 회원 수정 /members/{id} -> PATCH, PUT(게시글 수정 등 제한적인 상황), POST
- 회원 삭제 /members/{id} -> DELETE

클라이언트는 등록될 리소스의 URI 를 모른다.

- 회원 등록 /members -> POST
- POST /members

서버가 새로 등록된 리소스 URI를 생성해준다.

- HTTP/1.1 201 Created
  Location: /members/100

이 형태를 컬렉션 이라고 한다.

- 서버가 관리하는 리소스 디렉토리
- 서버가 리소스의 URI를 생성하고 관리
- 여기서 컬렉션은 /members

2. 파일 관리 시스템 API 설계 / PUT 기반 등록

- 파일 목록 /files -> GET
- 파일 조회 /files/{filename} -> GET
- 파일 등록 /files/{filename} -> PUT
- 파일 삭제 /files/{filename} -> DELETE
- 파일 대량 등록 /files -> POST

클라이언트가 리소스 URI를 알고 있어야 한다 (POST와 PUT의 큰 차이!!!)

- 파일 등록 /files/{filename} -> PUT
- PUT /files/filename.jpg

클라이언트가 직접 리소스의 URI를 지정한다. PUT 기반은 서버가 만들어주지 않는다.

이 형태를 스토어 라고 한다.

- 클라이언트가 관리하는 리소스 저장소
- 클라이언트가 리소스의 URI를 알고 관리
- 여기서 스토어는 /files

`대부분의 실무에서는 POST를 사용한다.`

3. HTML FORM 사용

- HTML FORM은 GET, POST 만 지원한다. -> 제약이 존재!
- AJAX같은 기술을 사용해서 해결 가능

- 회원 목록 /members -> GET
- 회원 등록 폼 /members/new -> GET
- 회원 등록 /members/new -> POST
- 회원 조회 /members/{id} -> GET
- 회원 수정 폼 /members/{id}/edit -> GET
- 회원 등록 /members/{id}/edit -> POST
- 회원 삭제 /members/{id}/delete -> POST --> DELETE를 사용 못하기에 컨트롤 URI 를 사용해야 한다.

컨트롤 URI

- HTML FORM은 GET, POST만 지원하므로 제약이 존재한다.
- 이런 제약을 해결하기 위해 동사로 된 리소스 경로 사용
- POST의 /new, /edit, /delete 등이 컨트롤 URI

### 참고하면 좋은 URI 설계 개념

https://restfulapi.net/resource-naming 참고하기!!

1. 문서
2. 컬렉션
3. 스토어
4. 컨트롤러

# HTTP 상태코드

상태코드란?

클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

- 1xx (informational): 요청이 수신되어 처리중

- 2xx (Successful): 요청 정상 처리

- 3xx (Redirection): 요청을 완료하려면 추가 행동이 필요

- 4xx (Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음

- 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

만약 모르는 상태 코드가 나온다면?

- 그냥 앞자리 수를 따라서 에러를 이해한다.(클라이언트는 상위 상태코드로 해석해서 처리한다)

상세 상태코드 설명

1. 1xx - 요청이 수신되어 처리중 / 거의 생략.

2. 2xx - 클라이언트의 요청을 성공적으로 처리

- 200 ok - 요청 성공
  결과를 정상적으로 잘 처리할 경우 보낸다.

- 201 Created - 요청 성공해서 새로운 리소스가 생성됨.
  생성된 리소스는 응답의 Location 헤더 필드로 식별한다.

- 202 Accepted - 요청이 접수되었으니 처리가 완료되지 않음
  ex) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리함
  `잘 사용하지 않는다!`

- 204 No Content - 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음.
  웹문서 편집기에서 저장 버튼을 눌렀을 때,
  버튼의 결과로 아무 내용이 없어도 됨.
  save 버튼을 눌러도 같은 화면을 유지해야 함.
  결과 내용이 없어도 204 메세지 만으로 성공을 인식할 수 있다.

3. 3xx - 리다이렉션 / 요청을 완료하기 위해 클라이언트의 추가 조치 필요

### 리다이렉션 이해

웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)

ex)

유저가 /event 라는 페이지로 이동시, 서버는 더이상 이 페이지를 사용하지 않고 /new-event 라는 페이지를 쓴다면

자동으로 서버에서 /new-event 페이지로 redirect 시킨다.

### 리다이렉션의 종류

- 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동

  - 301 Moved Permanently
    리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음
  - 308 Permanent Redirect
    301과 기능은 같지만 리다이렉트시 요청 메서드와 본문 유지
    즉, 회원가입등을 할 경우 POST로 보낼 시 본문을 유지해 메시지가 유지되어 다시 입력할 필요 없음.
    `하지만 이건 실무에서 거의 사용하지 않는다. 그냥 GET이 편함.`

- 일시 리다이렉션 - 일시적인 변경
  리소스의 URI가 일시적으로 변경, 따라서 검색 엔진 등에서 URL을 변경하면 안됨.
  ex: 주문 완료 후 주문 내역 화면으로 이동

  - 302 Found
    리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음 / `실무에서 제일 많이 씀`

  - 307 Temporary Redirect
    302와 기능은 같음.
    하지만 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다.)

  - 303 See Other
    302와 기능은 같음
    리다이렉트시 요청 메서드가 GET으로 변경

  - `일시적인 리다이렉션 예시`
    - POST로 주문 후에 웹 브라우저를 새로고침하면?
    - 새로고침은 다시 요청하게 되고(경고창이 뜸) 중복 주문이 들어가게 된다.
    - 이 경우에 POST 주문 후 결과 화면을 GET 메서드로 리다이렉트, 새로고침을 해도 결과 화면이 뜨기때문에 방지 가능.

- 기타 리다이렉션

  - 300 Multiple Choices - 안씀.

  - 304 Not Modified
    캐시를 목적으로 사용
    클라이언트에게 리소스가 수정되지 않았음을 알려줌. 따라서 클라이언트는 로컬 pc에 저장된 캐시를 재활용
    304 응답은 응답에 메시지 바디를 포함하지 않는다 (로컬 캐시를 쓰기때문)
    조건부 GET, HEAD를 사용할 시에만 사용한다.

4. 4xx - 클라이언트 오류
   클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없음.
   즉, `오류의 원인이 클라이언트에 있음`
   그렇기에 재시도를 해도 똑같이 잘못된 요청, 데이터를 보내기에 무조건 실패한다.

- 400 Bad Request - 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음.
  요청 구문, 메시지 등등 오류
  클라이언트는 요청 내용을 다시 검토하고 보내야 함
  ex: 요청 파라미터가 잘못되거나 API 스펙이 맞지 않을때

- 401 Unauthorized - 클라이언트가 해당 리소스에 대한 인증이 필요함. 즉, 인증되지 않음.
  401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
  인증 - 본인이 누구인지 확인(로그인)
  인가 - 권한부여 확인

- 403 Forbidden - 서버가 요청을 이해했지만 승인을 거부함
  ex: 어드민 등급이 아닌 사용자가 로그인은 했지만, 어드민 등급의 리소스에 접근하는 경우

- 404 Not Found - 요청 리소스를 찾을 수 없음
  요청 리소스가 서버에 없음
  또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을때.

5. 5xx - 서버 오류, 서버가 정상 요청을 처리하지 못함. `정말 필요한 경우 아니면, 절대 서버 에러는 만들면 안됀다!!!`
   재시도 하면 서버가 복구됐을 시 성공 가능.

- 500 Internal Server Error
  서버 문제로 오류 발생, 애매하면 500 오류

- 503 Service Unavailable - 서비스 이용 불가
  서버가 일시적인 과부하, 또는 예정된 작업(점검 등)으로 인해 잠시 요청을 처리 불가.

# HTTP 헤더 1

header-field = field-name ":" OWS field-value OWS (OWS : 띄어쓰기 허용)
field_name은 대소문자의 구분이 없다.

HTTP 헤더의 용도

- HTTP 전송에 필요한 모든 부가 정보 저장

message body - RFC723x

메시지 본문을 통해 표현 데이터 전달
메시지 본문 = 페이로드
표현은 요청이나 응답에서 전달할 실제 데이터
표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공 (데이터 유형, 데이터 길이, 압축 정보등)

### 표현

Content-Type: 표현 데이터의 형식
Content-Encoding: 표현 데이터의 압축 방식
Content-Language: 표현 데이터의 자연 언어
Content-Length: 표현 데이터의 길이

--> 표현 헤더는 전송, 응답 둘 다 사용

- Content Type - 표현 데이터의 형식 설명
  미디어 타입, 문자 인코딩 등.

- Content-Encoding - 표현 데이터를 압축하기 위해 사용
  데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
  데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제

- Content-Language - 표현 데이터의 자연 언어 표현
  ex: ko, en, en-US 등.

- Content-Length - 표현 데이터의 길이
  바이트 단위
  `Transfer-Encoding(전송 코딩)을 사용하면 Content-Length 를 사용하면 안된다.`

### 협상 (콘텐츠 네고시에이션)

클라이언트가 선호하는 표현 요청

- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accept-Language: 클라이언트가 선호하는 자연 언어
  --> 협상 헤더는 요청시에만 사용한다.

1. 협상과 우선순위1

협상시 우선순위를 두어서 내가 원하는 우선순위에 q값을 넣어

서버에서 해당 우선순위를 지원할 시 존재하는 우선순위 순으로 먼저 가져온다.

2. 협상과 우선순위2

구체적인 것이 우선!

/, text/, text/plain, text/plain;format=flowed

이 경우 제일 뒤에있는 것부터 우선순위를 가져간다.

### 전송 방식

- 단순전송 - Content-Length
  Content-Length를 지정한만큼 딱 전송.

- 압축전송 - Content-Encoding
  Content-Length를 압축하여(Content-Encoding 으로 압축방식 전달) 전달.

- 분할전송 - Transfer-Encoding
  chunk, 즉 덩어리로 쪼개서 보낸다.
  `분할전송을 할 때는 Content-Length를 보내면 안된다!`

- 범위전송 - Range, Content-Range
  중간에 전송이 끊길 경우, 처음부터 받는것이 아닌 해당 범위부터 다시 전송가능.

### 일반 정보

- From - 유저 에이전트의 이메일 정보
  일반적으로 잘 사용하지 않음
  검색 엔진 같은곳에서 사용
  요청에서 사용

- Referer - 현재 요청된 페이지의 이전 웹 페이지 정보(URl)
  Referer를 사용해서 유입 경로 분석 가능
  요청에서 사용

- User-Agent - 유저 에이전트 애플리케이션 정보
  클라이언트의 애플리케이션 정보
  통계 정보
  어떤 종류의 브라우저에서 장애가 발생하는지 파악가능
  요청에서 사용

- Server - 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
  응답에서 사용
  server: nginx
  Server: Apache/2.2.22 (Debian)

- Date - 메시지가 발생한 날짜와 시간
  응답에서 사용

### 특별한 정보

- Host - 요청한 호스트 정보(도메인)
  요청에서 사용
  필수
  하나의 서버가 여러 도메인을 처리해야 할 때
  하나의 IP 주소에 여러 도메인이 적용되어 있을 때

- Location - 페이지 리다이렉션
  201 의 값은 요청에 의해 생선된 리소스 URI
  3xx 의 Location 값은 요청을 자동으로 리다이렉션 하기 위한 대상 리소스를 가리킴

- Allow - 허용 가능한 HTTP 메서드 / `잘 사용하지 않는다`
  405 에서 응답에 포함해야함
  Allow: GET, HEAD, PUT

- Retry-After 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
  503 서비스가 언제까지 불능인지 알려줄 수 있음
  Retry-After: 날짜 표기 및 초단위 표기 등 가능함.

### 인증

- Authorization 클라이언트 인증 정보를 서버에 전달

- WWW-Authenticate 리소스 접근시 필요한 인증 방법 정의
  401 응답과 함께 사용한다.

### 쿠키

- Set-Cookie - 서버에서 클라이언트로 쿠키 전달
  Cookie - 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
  쿠키는 모든 요청에 쿠키 정보를 자동으로 포함해서 개발을 편하게 해준다.

  - 쿠키의 주 사용처
    사용자 로그인 세션 관리
    광고 정보 트래킹

  - 쿠키 정보는 항상 서버에 전송
    네트워크 추가 트래픽 유발
    그로 인해 최소한의 정보만 사용(세션 id, 인증 토큰)
    서버에 전송하지 않고 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 참고.

  - 주의사항
    보안에 민감한 데이터는 저장하면 안된다!!

- 쿠키의 기한

  - expires - 만료일이 되면 쿠키 삭제

  - max-age - 시간을 설정, 다 되면 쿠키 삭제

  - 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지

  - 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지

- 쿠키 - 도메인

  - domain=example.org
    명시한 문서 기준 도메인 + 서브 도메인을 포함한다.

  - domain 생략시
    example.org 에서 쿠키를 생성하고 domain 지정을 생략시,
    현재 문서 기준 도메인만 적용한다.

- 쿠키 - 경로
  ex: path=/home
  이 경로를 포함한 하위 경로 페이지만 쿠키 접근
  /home 가능, /home/level-1 가능, /home/level-1/level-2 가능
  /hello 쿠키 접근 불가능.

- 쿠키 - 보안

  - Secure
    쿠키는 http, https 를 구분하지 않고 전송하지만
    Secure를 적용하면 https인 경우에만 전송한다.

  - HttpOnly
    XSS 공격 방지
    자바스크립트에서 접근 불가
    HTTP 전송에만 사용

  - SameSite
    XSRF 공격 방지
    요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송

# HTTP 헤더 2 - 캐시와 조건부 요청

### 캐시와 기본 동작

- 캐시가 없을 때
  같은 요청을 반복시, 계속 같은 용량을 전달하게 된다.
  인터넷 네트워크는 매우 느리고 비쌈
  브라우저 로딩 속도가 느림
  느린 사용자 경험

- 캐시가 있을 때
  cache-control 을 적용하면 캐시 저장 기한 설정 가능.
  이럴 경우 브라우저 캐시에 저장, 캐시 유호 기간 확인 후 캐시에서 조회.
  캐시 덕분에 네트워크를 사용하지 않아도 됨.
  네트워크 사용량을 줄일 수 있음
  브라우저 로딩 속도가 매우 빠름
  뻐른 사용자 경험

- 캐시 시간 초과
  캐시 유효 시간 검증시 시간초과를 했다면
  다시 서버에서 데이타를 받고, 응답 결과를 다시 캐시에 저장.
  이는 조건부 요청을 통해 개선 가능하다.

### 검증 헤더와 조건부 요청 1

캐시 유효 시간이 초과해 서버에 요청하면 두가지 상황이 나타난다

1. 서버에서 기존 데이터 변경 --> 새로 데이터를 받아야 함
2. 서버에서 기존 데이터를 변경하지 않음 --> 데이터가 같다는걸 비교 후, 기존에 저장해 둔 캐시를 재사용!

2의 경우, 검증 헤더를 추가해서 해결 가능하다. (Last-Modified)
데이터의 최종 수정일을 기록해 변경이 없다면 그대로 재사용 가능! / if-modified-since True: 재사용!
이때 HTTP 304 Not Modified 에서 Body 없이 응답을 보내면 네트워크 부하가 확 준다.
그 이후 캐시에서 다시 조회

정리

1. 캐시 유효시간이 초과해도 서버의 데이터가 갱신되지 않으면 304 Not Modified + 헤더 메타 정보 전송
2. 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보 갱신
3. 클라이언트는 캐시에 저장된 데이터 재사용
4. 네트워크 다운로드가 발생하지만 용량이 매우 적음
5. 이 해결책은 매우 실용적!

### 검증 헤더와 조건부 요청 2

검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified, ETag

조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since: Last-Modified 사용
- If-None-Match: ETag 사용
- 조건 만족시 200 ok
- 조건 불만족시 304 Not Modified

If-Modified-Since: 이후에 데이터 수정시

- 데이터 미변경시
  304 Not Modified, 헤더 데이터만 전송(BODY 미포함)
  전송 용량 0.1M (Only 헤더)

- 데이터 변경시
  200 OK, 모든 데이터 전송(BODY 포함)
  전송 용량 1.1M (헤더 + 바디)

- Last-Modified, If-Modified-Since 단점
  1초 미만 단위 캐시조정 불가능
  날짜 기반 로직 사용
  데이터를 수정해서 날짜가 다르지만, 결국 데이터 결과가 똑같은 경우 (컨텐츠는 동일, 날짜만 다름) 다시 다운받음.
  서버에서 별도로 캐시 로직을 관리하고 싶은 경우(주석처럼 영향을 끼치지 않는 선에서 캐시를 유지하고 싶은 경우)

`이럴때 ETag를 사용하면 해당 단점들을 극복할 수 있다!`

- ETag, If-None-Match

  - 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
    ex: ETag:"v1.0", ETag:"asdqwe12"

  - 데이터가 변경되면 이 이름을 바꾸어서 변경함
    ETag:"aaaaa" -> ETag:"bbbbb"

  - 즉, ETag만 보내서 같으면 유지, 다르면 다시 다운로드(변경)
    서버와 ETag를 비교, 동일하면 HTTP BODY를 보내지 않고 헤더 데이터만 갱신해 브라우저에 저장한다.

정리

1. 캐시 제어 로직을 서버에서 완전히 관리
2. 클라이언트는 단순히 이 값을 서버에 제공 (클라이언트는 캐시 메커니즘을 모른다.)

### 캐시와 조건부 요청 헤더

캐시 제어 헤더

- Cache-Control - 캐시 지시어

  - Cache-Control: max-age
    캐시 유효 시간, 초 단위

  - Cache-Control: no-cache
    데이터는 캐시해도 되지만, 항상 Origin 서버에 검증하고 사용

  - Cache-Control: no-store
    데이터에 민감한 정보가 있으므로 저장하면 안됨
    (메모리에서 사용하고 최대한 빨리 삭제)

- Expires - 캐시 만료일 지정(하위 호환)
  캐시 만료일은 정확한 날짜로 지정
  지금은 max-age 사용 권장.

### 프록시 캐시

원 서버에서 다운받는 시간이 긴 경우,

따로 프록시 캐시 서버를 두어 시간을 단축시킨다.

### 캐시 무효화

- Cache-Control: no-cache, no-store, must-revalidate / Pragma: no-cache
  브라우저에서 지 맘대로 캐시를 해버릴 수 있기 때문에,
  위와 같이 설정해서 캐시하면 안되는 페이지는 절대 캐시를 하지 못하게 만들어야 한다.

- no-cache
  데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용

- no-store
  데이터에 민감한 정보가 있으므로 저장하면 안됨
  (메모리에서 사용하고 최대한 빨리 삭제)

- must-revalidate
  캐시 만료후 최초 조회시 원 서버에 검증해야 함
  원 서버 접근 실패시 반드시 오류가 발생해야 함 - 504 Gatewat Timeout
  must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
  `원 서버에 접근할 수 없는 경우를 위해 no-cache와 같이 사용한다.`

- Pragma: no-cache
  HTTP 1.0 하위 호환
